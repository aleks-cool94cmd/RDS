#!/usr/bin/env node

const fs = require('fs');
const fsp = require('fs/promises');
const path = require('path');

const ROOT_DIR = path.join(__dirname, '..');
const DEFAULT_DB_PATH = path.join(ROOT_DIR, 'server', 'data', 'users-db.json');
const DEFAULT_BACKUP_DIR = path.join(ROOT_DIR, 'server', 'data', 'backups');
const DEFAULT_EXPORT_DIR = path.join(ROOT_DIR, 'server', 'data', 'exports');

function resolveDbPath() {
  const raw = String(process.env.USERS_DB_PATH || '').trim();
  if (!raw) return DEFAULT_DB_PATH;
  return path.isAbsolute(raw) ? raw : path.resolve(ROOT_DIR, raw);
}

function timestamp() {
  const now = new Date();
  const YYYY = now.getFullYear();
  const MM = String(now.getMonth() + 1).padStart(2, '0');
  const DD = String(now.getDate()).padStart(2, '0');
  const hh = String(now.getHours()).padStart(2, '0');
  const mm = String(now.getMinutes()).padStart(2, '0');
  const ss = String(now.getSeconds()).padStart(2, '0');
  return `${YYYY}${MM}${DD}-${hh}${mm}${ss}`;
}

async function ensureDbFile(dbPath) {
  await fsp.mkdir(path.dirname(dbPath), { recursive: true });
  if (!fs.existsSync(dbPath)) {
    await fsp.writeFile(dbPath, JSON.stringify({ users: [], subscriptions: [] }, null, 2), 'utf8');
  }
}

async function readDb(dbPath) {
  await ensureDbFile(dbPath);
  const raw = await fsp.readFile(dbPath, 'utf8');
  const parsed = JSON.parse(raw);
  parsed.users = Array.isArray(parsed.users) ? parsed.users : [];
  parsed.subscriptions = Array.isArray(parsed.subscriptions) ? parsed.subscriptions : [];
  return parsed;
}

function escapeSql(value) {
  return String(value).replace(/'/g, "''");
}

function toSqlLiteral(value) {
  if (value === null || value === undefined) return 'NULL';
  if (typeof value === 'number' || typeof value === 'bigint') return String(value);
  if (typeof value === 'boolean') return value ? 'TRUE' : 'FALSE';
  return `'${escapeSql(value)}'`;
}

function toJsonbLiteral(value) {
  return `'${escapeSql(JSON.stringify(value ?? {}))}'::jsonb`;
}

function sqlHeader() {
  return [
    '-- CycleFlow users export',
    '-- Generated by scripts/db-tools.js',
    '',
    'BEGIN;',
    '',
    'CREATE TABLE IF NOT EXISTS users (',
    '  id UUID PRIMARY KEY,',
    '  email TEXT NOT NULL UNIQUE,',
    '  name TEXT NOT NULL,',
    '  password_salt TEXT NOT NULL,',
    '  password_hash TEXT NOT NULL,',
    '  created_at TIMESTAMPTZ NOT NULL,',
    '  updated_at TIMESTAMPTZ NOT NULL,',
    '  data_json JSONB NOT NULL DEFAULT \'{}\'::jsonb',
    ');',
    '',
    'CREATE TABLE IF NOT EXISTS push_subscriptions (',
    '  endpoint TEXT PRIMARY KEY,',
    '  payload JSONB NOT NULL DEFAULT \'{}\'::jsonb,',
    '  created_at TIMESTAMPTZ NOT NULL DEFAULT NOW()',
    ');',
    ''
  ].join('\n');
}

function usersToSql(users) {
  if (!users.length) return '-- No users found.\n';
  return users.map((user) => {
    return [
      'INSERT INTO users (id, email, name, password_salt, password_hash, created_at, updated_at, data_json)',
      `VALUES (${toSqlLiteral(user.id)}, ${toSqlLiteral(user.email)}, ${toSqlLiteral(user.name)}, ${toSqlLiteral(user.passwordSalt)}, ${toSqlLiteral(user.passwordHash)}, ${toSqlLiteral(user.createdAt)}, ${toSqlLiteral(user.updatedAt)}, ${toJsonbLiteral(user.data)} )`,
      'ON CONFLICT (id) DO UPDATE SET',
      '  email = EXCLUDED.email,',
      '  name = EXCLUDED.name,',
      '  password_salt = EXCLUDED.password_salt,',
      '  password_hash = EXCLUDED.password_hash,',
      '  created_at = EXCLUDED.created_at,',
      '  updated_at = EXCLUDED.updated_at,',
      '  data_json = EXCLUDED.data_json;',
      ''
    ].join('\n');
  }).join('\n');
}

function subscriptionsToSql(subscriptions) {
  if (!subscriptions.length) return '-- No push subscriptions found.\n';
  return subscriptions.map((sub) => {
    const endpoint = sub && typeof sub === 'object' ? sub.endpoint : '';
    return [
      'INSERT INTO push_subscriptions (endpoint, payload)',
      `VALUES (${toSqlLiteral(endpoint)}, ${toJsonbLiteral(sub)} )`,
      'ON CONFLICT (endpoint) DO UPDATE SET',
      '  payload = EXCLUDED.payload;',
      ''
    ].join('\n');
  }).join('\n');
}

async function cmdStatus() {
  const dbPath = resolveDbPath();
  const db = await readDb(dbPath);
  const size = (await fsp.stat(dbPath)).size;
  console.log(`DB path: ${dbPath}`);
  console.log(`Users: ${db.users.length}`);
  console.log(`Push subscriptions: ${db.subscriptions.length}`);
  console.log(`Size: ${size} bytes`);
}

async function cmdBackup() {
  const dbPath = resolveDbPath();
  await ensureDbFile(dbPath);
  await fsp.mkdir(DEFAULT_BACKUP_DIR, { recursive: true });
  const backupPath = path.join(DEFAULT_BACKUP_DIR, `users-db-${timestamp()}.json`);
  await fsp.copyFile(dbPath, backupPath);
  console.log(`Backup created: ${backupPath}`);
}

async function cmdExportSql(outputArg) {
  const dbPath = resolveDbPath();
  const db = await readDb(dbPath);
  await fsp.mkdir(DEFAULT_EXPORT_DIR, { recursive: true });
  const outputPath = outputArg
    ? (path.isAbsolute(outputArg) ? outputArg : path.resolve(ROOT_DIR, outputArg))
    : path.join(DEFAULT_EXPORT_DIR, `users-export-${timestamp()}.sql`);

  const content = [
    sqlHeader(),
    usersToSql(db.users),
    subscriptionsToSql(db.subscriptions),
    'COMMIT;',
    ''
  ].join('\n');

  await fsp.mkdir(path.dirname(outputPath), { recursive: true });
  await fsp.writeFile(outputPath, content, 'utf8');
  console.log(`SQL export created: ${outputPath}`);
}

async function main() {
  const cmd = process.argv[2];
  const arg = process.argv[3];

  if (cmd === 'status') {
    await cmdStatus();
    return;
  }
  if (cmd === 'backup') {
    await cmdBackup();
    return;
  }
  if (cmd === 'export-sql') {
    await cmdExportSql(arg);
    return;
  }

  console.error('Usage: node scripts/db-tools.js <status|backup|export-sql> [outputPath]');
  process.exitCode = 1;
}

main().catch((err) => {
  console.error('DB tool error:', err?.message || err);
  process.exitCode = 1;
});
